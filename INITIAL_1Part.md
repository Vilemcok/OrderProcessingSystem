## FEATURE:

I want you to generate a complete ASP.NET Core Web API backend project
based strictly on the following requirements.
Do NOT make any assumptions beyond what is written here.

GENERAL:
- Use ASP.NET Core Web API with Controllers (not Minimal API)
- Use GUIDs as IDs for all entities
- No API versioning
- Use clean architecture structure (Controllers, Services, Repositories)
- Never expose EF entities directly – always use DTOs

AUTHENTICATION:
- Implement JWT Bearer authentication
- Login via email + password
- JWT claims must include: userId, email, name
- Use default ASP.NET Core PasswordHasher
- JWT expiration: 1 hour
- Protect all endpoints with JWT authentication
- No roles, no authorization levels – every authenticated user can access all endpoints

DATABASE:
- PostgreSQL
- Entity Framework Core
- EF Core Migrations as DB upgrade mechanism
- Include initial seed data via migrations

DOCKER:
- Provide docker-compose file only for PostgreSQL
- Use predefined database user credentials
- API runs locally (not in Docker)

USERS MODULE:
- Fields: id (GUID), name (max 100), email (max 100, unique), password
- CRUD REST API
- Validate DTOs, return 400 on invalid input
- Enforce unique email at database level
- Never return password in API responses

PRODUCTS MODULE:
- Fields: id (GUID), name (max 100), description, price (>= 0), stock (>= 0), created_at
- created_at generated by server
- CRUD REST API
- Validate DTOs, return 400 on invalid input

ORDERS MODULE:
- Fields: id, user_id, total (>= 0), status enum (pending, processing, completed, expired),
  created_at, updated_at
- OrderItems:
  - id (PK)
  - product_id
  - quantity (> 0)
  - price (> 0)
- total is NOT provided by client
- total is calculated server-side as sum(item.price * quantity)
- think about causaility like: 
  - Validate product stock availability before creating order
  - If stock is insufficient, return 400
  - After order creation, decrease product stock accordingly
- Use a database transaction to ensure consistency when creating orders and items

ERROR HANDLING:
- 400 Bad Request – validation and business rule violations
- 401 Unauthorized – missing or invalid JWT
- 404 Not Found – entity not found
- 500 Internal Server Error – global exception handling middleware

SWAGGER:
- Include OpenAPI / Swagger
- Configure Swagger to support JWT Bearer authentication
- Document request and response DTOs

TESTING:
- Use xUnit
- Use Testcontainers for PostgreSQL
- Implement at least 5 integration tests covering:
  - authentication
  - protected endpoints
  - order creation with stock validation

README:
- Document how to:
  - start PostgreSQL via docker-compose
  - run EF Core migrations / DB upgrade
  - run the API
  - run integration tests

IMPORTANT RULES:
- Do not simplify requirements
- Do not invent extra features
- Ask me before making any architectural decision not covered here
- Generate clean, readable, production-style code

## DOCUMENTATION:

When implementing the solution, follow the official documentation and best practices from these sources:

- ASP.NET Core Web API:
  https://learn.microsoft.com/en-us/aspnet/core/web-api/

- ASP.NET Core Authentication & JWT:
  https://learn.microsoft.com/en-us/aspnet/core/security/authentication/
  https://learn.microsoft.com/en-us/aspnet/core/security/authentication/jwt

- Entity Framework Core:
  https://learn.microsoft.com/en-us/ef/core/
  https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/
  https://learn.microsoft.com/en-us/ef/core/saving/transactions

- PostgreSQL EF Core provider (Npgsql):
  https://www.npgsql.org/efcore/

- Swagger / OpenAPI:
  https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle

- Docker Compose & PostgreSQL:
  https://docs.docker.com/compose/
  https://hub.docker.com/_/postgres

- Testing:
  https://xunit.net/docs/getting-started/netcore
  https://dotnet.testcontainers.org/
  https://dotnet.testcontainers.org/modules/databases/postgres/

If there is any conflict between generated code and these sources,
follow the official documentation.

## OTHER CONSIDERATIONS:

- The generated solution must be immediately runnable in Visual Studio
- Opening the solution and pressing F5 must start the Web API without additional configuration
- Swagger UI must be enabled and accessible automatically on application startup
- Configure Swagger only for Development environment